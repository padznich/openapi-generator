from __future__ import annotations
{{#vendorExtensions.x-py-other-imports}}
{{{.}}}
{{/vendorExtensions.x-py-other-imports}}
{{#vendorExtensions.x-py-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-model-imports}}
from pydantic import StrictStr, Field, RootModel
from typing import Union, List, Set, Optional, Dict
from typing_extensions import Literal, Self

{{#lambda.uppercase}}{{{classname}}}{{/lambda.uppercase}}_ONE_OF_SCHEMAS = [{{#oneOf}}"{{.}}"{{^-last}}, {{/-last}}{{/oneOf}}]


class {{classname}}(RootModel[Union[{{#oneOf}}{{{.}}}{{^-last}}, {{/-last}}{{/oneOf}}]]):
    """
    {{{description}}}{{^description}}{{{classname}}}{{/description}}
    """
    root: Union[{{#oneOf}}{{.}}{{^-last}}, {{/-last}}{{/oneOf}}{{#isNullable}}, None{{/isNullable}}] = Field(
      {{#isNullable}}None{{/isNullable}}{{^isNullable}}...{{/isNullable}}{{#discriminator}}, discriminator="{{discriminatorName}}"{{/discriminator}}
    )

    def __getattr__(self, name):
        """
        Delegate attribute access to the root model if the attribute
        doesn't exist on the main class.
        """

        if name in self.__dict__:
            return super().__getattribute__(name)

        root = self.__dict__.get('root')
        if root is not None:
            return getattr(root, name)

        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

{{#vendorExtensions.x-py-postponed-model-imports.size}}
{{#vendorExtensions.x-py-postponed-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-postponed-model-imports}}
# TODO: Rewrite to not use raise_errors
{{classname}}.model_rebuild(raise_errors=False)
{{/vendorExtensions.x-py-postponed-model-imports.size}}
